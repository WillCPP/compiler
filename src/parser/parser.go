// The entry point function is Parse
// Parse setups the builtinsSymbolTable.
// The function then calls parseProgram which begins
// parsing the token list generated by the scanner.
// The parser generates a parse tree.  Functions such as
// ParseProcedureBody or ParseExpression are responsible
// for generating a sub tree.

package parser

import (
	"compiler/src/types"
	"errors"
	"log"
)

var tokenIndex int = 0
var tokenList []types.Token
var currentToken types.Token
var parseTreeRoot types.ParseNode
var globalSymbolTable = map[string]types.STEntry{}
var builtinSymbolTable = map[string]types.STEntry{}

func Parse(tokenListArg []types.Token) types.ParseNode {
	tokenList = tokenListArg

	// Add builtin functions to globalSymbolTable
	builtinSymbolTable["getbool"] = types.STEntry{Identifier: "getbool", EntryType: types.STProcedure, ProcedureReturnType: types.STVarBool}
	builtinSymbolTable["getinteger"] = types.STEntry{Identifier: "getinteger", EntryType: types.STProcedure, ProcedureReturnType: types.STVarInteger}
	builtinSymbolTable["getfloat"] = types.STEntry{Identifier: "getfloat", EntryType: types.STProcedure, ProcedureReturnType: types.STVarFloat}
	builtinSymbolTable["getstring"] = types.STEntry{Identifier: "getstring", EntryType: types.STProcedure, ProcedureReturnType: types.STVarString}
	stePutBool := types.STEntry{Identifier: "putbool", EntryType: types.STProcedure, ProcedureReturnType: types.STVarBool}
	stePutBool.ProcedureArgTypes = append(stePutBool.ProcedureArgTypes, types.STVarBool)
	builtinSymbolTable["putbool"] = stePutBool
	stePutInteger := types.STEntry{Identifier: "putinteger", EntryType: types.STProcedure, ProcedureReturnType: types.STVarBool}
	stePutInteger.ProcedureArgTypes = append(stePutInteger.ProcedureArgTypes, types.STVarInteger)
	builtinSymbolTable["putinteger"] = stePutInteger
	stePutFloat := types.STEntry{Identifier: "putfloat", EntryType: types.STProcedure, ProcedureReturnType: types.STVarBool}
	stePutFloat.ProcedureArgTypes = append(stePutFloat.ProcedureArgTypes, types.STVarFloat)
	builtinSymbolTable["putfloat"] = stePutFloat
	stePutString := types.STEntry{Identifier: "putstring", EntryType: types.STProcedure, ProcedureReturnType: types.STVarBool}
	stePutString.ProcedureArgTypes = append(stePutString.ProcedureArgTypes, types.STVarString)
	builtinSymbolTable["putstring"] = stePutString
	steSqrt := types.STEntry{Identifier: "sqrt", EntryType: types.STProcedure, ProcedureReturnType: types.STVarFloat}
	steSqrt.ProcedureArgTypes = append(steSqrt.ProcedureArgTypes, types.STVarInteger)
	builtinSymbolTable["sqrt"] = steSqrt

	err := ParseProgram()
	if err != nil {
		log.Fatal(err)
	}
	return parseTreeRoot
}

func PrintParseNodes(node *types.ParseNode, indent int) {
	indentStr := ""
	for i := 0; i < indent; i++ {
		indentStr += "    "
	}
	str := (*node).TerminalToken.StringValue
	println(indentStr, (*node).Production, "  |  ", (*node).TerminalToken.TokenType, "    ", str)
	for _, val := range (*node).ChildNodes {
		PrintParseNodes(&val, indent+1)
	}
}

func GetNextToken() {
	currentToken = tokenList[tokenIndex]
	tokenIndex++
}

func CheckTokenType(checkType types.TokenType) bool {
	if currentToken.TokenType == checkType {
		return true
	}
	return false
}

func CheckLookAhead(checkType types.TokenType) bool {
	if tokenList[tokenIndex].TokenType == checkType {
		return true
	}
	return false
}

func AddSymbolTableEntry(makeGlobal bool, stEntry types.STEntry, localSymbolTable *map[string]types.STEntry) error {
	strErrorGlobalExists := "\nError: This global symbol has already been declared"
	strErrorLocalExists := "\nError: This local symbol has already been declared"
	strErrorBuiltinExists := "\nError: Cannot overload builtin function"

	_, builtinExists := builtinSymbolTable[stEntry.Identifier]
	if builtinExists {
		return errors.New(strErrorBuiltinExists)
	}

	if makeGlobal {
		_, exists := globalSymbolTable[stEntry.Identifier]
		if exists {
			return errors.New(strErrorGlobalExists)
		} else {
			globalSymbolTable[stEntry.Identifier] = stEntry
		}
	}

	if localSymbolTable == nil {
		return nil
	}

	_, exists := (*localSymbolTable)[stEntry.Identifier]
	if exists {
		return errors.New(strErrorLocalExists)
	} else {
		(*localSymbolTable)[stEntry.Identifier] = stEntry
	}

	return nil
}

func ParseProgram() error {
	node := types.ParseNode{Production: types.ProgramProd}
	parseTreeRoot = node
	errString := "Error parsing program"

	err := ParseProgramHeader(&parseTreeRoot)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	err = ParseProgramBody(&parseTreeRoot)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	return nil
}

func IdentifierProd(parentNode *types.ParseNode) error {
	return nil
}

func ParseProgramHeader(parentNode *types.ParseNode) error {
	programHeaderNode := types.ParseNode{Production: types.ProgramHeaderProd}
	errString := "\nError parsing program header"

	GetNextToken()
	if !CheckTokenType(types.ProgramKeyword) {
		return errors.New(errString)
	}
	programHeaderNode.ChildNodes = append(programHeaderNode.ChildNodes, types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken})

	GetNextToken()
	if !CheckTokenType(types.IdentifierToken) {
		return errors.New(errString)
	}
	programHeaderNode.ChildNodes = append(programHeaderNode.ChildNodes, types.ParseNode{Production: types.IdentifierProd, TerminalToken: currentToken})

	GetNextToken()
	if !CheckTokenType(types.IsKeyword) {
		return errors.New(errString)
	}
	programHeaderNode.ChildNodes = append(programHeaderNode.ChildNodes, types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken})

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, programHeaderNode)

	return nil
}

func ParseProgramBody(parentNode *types.ParseNode) error {
	programBodyNode := types.ParseNode{Production: types.ProgramBodyProd}
	errString := "\nError parsing program body"

	cont := true
	var err error

	GetNextToken()
	for cont { //TODO: replace cont with true
		if CheckTokenType(types.BeginKeyword) {
			// append begin node
			beginNode := types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken}
			programBodyNode.ChildNodes = append(programBodyNode.ChildNodes, beginNode)
			break
		}
		cont, err = ParseDeclaration(&programBodyNode, true, nil)

		if err != nil {
			return errors.New(errString + err.Error())
		}
		if CheckTokenType(types.SemiColonSymbol) {
			semiColonNode := types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken}
			programBodyNode.ChildNodes = append(programBodyNode.ChildNodes, semiColonNode)
		} else {
			return errors.New(errString)
		}

		GetNextToken()
	}

	GetNextToken()
	// Parse Statements here
	for {
		if CheckTokenType(types.EndKeyword) {
			break
		}
		emptyLocalSymbolTable := map[string]types.STEntry{}
		err = ParseStatement(&programBodyNode, &(emptyLocalSymbolTable))

		if err != nil {
			return errors.New(errString + err.Error())
		}
		GetNextToken()
		if CheckTokenType(types.SemiColonSymbol) {
			semiColonNode := types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken}
			programBodyNode.ChildNodes = append(programBodyNode.ChildNodes, semiColonNode)
		} else {
			return errors.New(errString)
		}

		GetNextToken()
	}

	// Parse Program footer here
	if !CheckTokenType(types.EndKeyword) {
		return errors.New(errString)
	}
	endKeywordNode := types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken}
	programBodyNode.ChildNodes = append(programBodyNode.ChildNodes, endKeywordNode)

	GetNextToken()
	if !CheckTokenType(types.ProgramKeyword) {
		return errors.New(errString)
	}
	progKeywordNode := types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken}
	programBodyNode.ChildNodes = append(programBodyNode.ChildNodes, progKeywordNode)

	GetNextToken()
	if !CheckTokenType(types.PeriodSymbol) {
		return errors.New(errString)
	}
	periodNode := types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken}
	programBodyNode.ChildNodes = append(programBodyNode.ChildNodes, periodNode)

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, programBodyNode)

	return nil
}

func ParseDeclaration(parentNode *types.ParseNode, makeGlobal bool, localSymbolTable *map[string]types.STEntry) (bool, error) {
	declarationNode := types.ParseNode{Production: types.DeclarationProd}
	errString := "\nError parsing declaration"
	thisMakeGlobal := makeGlobal

	// GetNextToken()
	if CheckTokenType(types.GlobalKeyword) {
		thisMakeGlobal = true
		globalNode := types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken}
		declarationNode.ChildNodes = append(declarationNode.ChildNodes, globalNode)
		GetNextToken()
	}

	if CheckTokenType(types.ProcedureKeyword) {
		err := ParseProcedureDeclaration(&declarationNode, thisMakeGlobal, localSymbolTable)
		if err != nil {
			return false, errors.New(errString + err.Error())
		}
	} else if CheckTokenType(types.VariableKeyword) {
		err := ParseVariableDeclaration(&declarationNode, thisMakeGlobal, localSymbolTable)
		if err != nil {
			return false, errors.New(errString + err.Error())
		}
	} else {
		return false, errors.New(errString)
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, declarationNode)

	return true, nil
}

func ParseProcedureDeclaration(parentNode *types.ParseNode, makeGlobal bool, localSymbolTable *map[string]types.STEntry) error {
	procDecNode := types.ParseNode{Production: types.ProcedureDeclarationProd}
	errString := "\nError parsing procedure declaration"
	thisMakeGlobal := makeGlobal
	procLocalSymbolTable := map[string]types.STEntry{}

	err := ParseProcedureHeader(&procDecNode, thisMakeGlobal, localSymbolTable, &procLocalSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	err = ParseProcedureBody(&procDecNode, &procLocalSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}
	GetNextToken()

	procDecNode.ProcLocalSymbolTable = procLocalSymbolTable

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, procDecNode)

	return nil
}

func ParseProcedureHeader(parentNode *types.ParseNode, makeGlobal bool, localSymbolTable *map[string]types.STEntry, procLocalSymbolTable *map[string]types.STEntry) error {
	procHeaderNode := types.ParseNode{Production: types.ProcedureHeaderProd}
	errString := "\nError parsing procedure header"
	thisMakeGlobal := makeGlobal
	procHeaderSTEntry := types.STEntry{}
	procHeaderSTEntry.EntryType = types.STProcedure

	if !CheckTokenType(types.ProcedureKeyword) {
		return errors.New(errString)
	}
	procHeaderNode.ChildNodes = append(procHeaderNode.ChildNodes, types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken})

	GetNextToken()
	if !CheckTokenType(types.IdentifierToken) {
		return errors.New(errString)
	}
	procHeaderNode.ChildNodes = append(procHeaderNode.ChildNodes, types.ParseNode{Production: types.IdentifierProd, TerminalToken: currentToken})
	procHeaderSTEntry.Identifier = currentToken.StringValue

	GetNextToken()
	if !CheckTokenType(types.ColonSymbol) {
		return errors.New(errString)
	}
	procHeaderNode.ChildNodes = append(procHeaderNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})

	GetNextToken()
	if CheckTokenType(types.IntegerKeyword) ||
		CheckTokenType(types.FloatKeyword) ||
		CheckTokenType(types.StringKeyword) ||
		CheckTokenType(types.BoolKeyword) {
		procHeaderNode.ChildNodes = append(procHeaderNode.ChildNodes, types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken})
	} else {
		return errors.New(errString)
	}
	procHeaderSTEntry.ProcedureReturnType = types.STType(currentToken.TokenType)

	GetNextToken()
	if !CheckTokenType(types.OpenRoundBracket) {
		return errors.New(errString)
	}
	procHeaderNode.ChildNodes = append(procHeaderNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})

	GetNextToken()
	if CheckTokenType(types.CloseRoundBracket) {
		procHeaderNode.ChildNodes = append(procHeaderNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})
	} else {
		// Parse parameter list
		err := ParseParameterList(&procHeaderNode, false, &procHeaderSTEntry, procLocalSymbolTable)
		if err != nil {
			return errors.New(errString + err.Error())
		}

		// GetNextToken()
		if CheckTokenType(types.CloseRoundBracket) {
			procHeaderNode.ChildNodes = append(procHeaderNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})
		}
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, procHeaderNode)
	err := AddSymbolTableEntry(thisMakeGlobal, procHeaderSTEntry, localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}
	err = AddSymbolTableEntry(false, procHeaderSTEntry, procLocalSymbolTable) // Allows for procedure to be seen locally for recursive calls
	if err != nil {
		return errors.New(errString + err.Error())
	}

	return nil
}

func ParseProcedureBody(parentNode *types.ParseNode, localSymbolTable *map[string]types.STEntry) error {
	procBodyNode := types.ParseNode{Production: types.ProcedureBodyProd}
	errString := "\nError parsing procedure body"

	cont := true
	var err error

	GetNextToken()
	for cont {
		if CheckTokenType(types.BeginKeyword) {
			// append begin node
			beginNode := types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken}
			procBodyNode.ChildNodes = append(procBodyNode.ChildNodes, beginNode)
			break
		}
		cont, err = ParseDeclaration(&procBodyNode, false, localSymbolTable)
		if err != nil {
			return errors.New(errString + err.Error())
		}
		if CheckTokenType(types.SemiColonSymbol) {
			semiColonNode := types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken}
			procBodyNode.ChildNodes = append(procBodyNode.ChildNodes, semiColonNode)
		} else {
			return errors.New(errString)
		}

		GetNextToken()
	}

	GetNextToken()
	// Parse Statements here
	for {
		if CheckTokenType(types.EndKeyword) {
			break
		}
		err = ParseStatement(&procBodyNode, localSymbolTable)
		if err != nil {
			return errors.New(errString + err.Error())
		}
		GetNextToken()
		if CheckTokenType(types.SemiColonSymbol) {
			semiColonNode := types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken}
			procBodyNode.ChildNodes = append(procBodyNode.ChildNodes, semiColonNode)
		} else {
			return errors.New(errString)
		}

		GetNextToken()
	}

	// Parse procedure footer here
	if !CheckTokenType(types.EndKeyword) {
		return errors.New(errString)
	}
	endKeywordNode := types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken}
	procBodyNode.ChildNodes = append(procBodyNode.ChildNodes, endKeywordNode)

	GetNextToken()
	if !CheckTokenType(types.ProcedureKeyword) {
		return errors.New(errString)
	}
	procKeywordNode := types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken}
	procBodyNode.ChildNodes = append(procBodyNode.ChildNodes, procKeywordNode)

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, procBodyNode)

	return nil
}

func ParseParameterList(parentNode *types.ParseNode, makeGlobal bool, procHeaderSTEntry *types.STEntry, localSymbolTable *map[string]types.STEntry) error {
	paramListNode := types.ParseNode{Production: types.ParamaterListProd}
	errString := "\nError parsing parameter list"

	for {
		err := ParseParameter(&paramListNode, false, procHeaderSTEntry, localSymbolTable)
		if err != nil {
			return errors.New(errString + err.Error())
		}
		if CheckTokenType(types.CommaSymbol) {
			paramListNode.ChildNodes = append(paramListNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})
			GetNextToken()
		} else if CheckTokenType(types.CloseRoundBracket) {
			(*parentNode).ChildNodes = append((*parentNode).ChildNodes, paramListNode)
			return nil
		} else {
			return errors.New(errString)
		}
	}
	return nil
}

func ParseParameter(parentNode *types.ParseNode, makeGlobal bool, procHeaderSTEntry *types.STEntry, localSymbolTable *map[string]types.STEntry) error {
	paramNode := types.ParseNode{Production: types.ParamaterProd}
	errString := "\nError parsing parameter"

	err := ParseVariableDeclaration(&paramNode, false, localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	nodes := paramNode.ChildNodes[0].ChildNodes
	if len(nodes) == 4 {
		procHeaderSTEntry.ProcedureArgTypes = append(
			procHeaderSTEntry.ProcedureArgTypes,
			types.STType(nodes[3].TerminalToken.TokenType))
	} else if len(nodes) == 7 {
		procHeaderSTEntry.ProcedureArgTypes = append(
			procHeaderSTEntry.ProcedureArgTypes,
			types.STType(nodes[3].TerminalToken.TokenType+"_array"))
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, paramNode)

	return nil
}

func ParseVariableDeclaration(parentNode *types.ParseNode, makeGlobal bool, localSymbolTable *map[string]types.STEntry) error {
	varDecNode := types.ParseNode{Production: types.VariableDeclarationProd}
	errString := "\nError parsing variable declaration"
	thisMakeGlobal := makeGlobal
	varDecSTEntry := types.STEntry{}

	if !CheckTokenType(types.VariableKeyword) {
		return errors.New(errString)
	}
	varDecNode.ChildNodes = append(varDecNode.ChildNodes, types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken})

	GetNextToken()
	if !CheckTokenType(types.IdentifierToken) {
		return errors.New(errString)
	}
	varDecNode.ChildNodes = append(varDecNode.ChildNodes, types.ParseNode{Production: types.IdentifierProd, TerminalToken: currentToken})
	varDecSTEntry.Identifier = currentToken.StringValue

	GetNextToken()
	if !CheckTokenType(types.ColonSymbol) {
		return errors.New(errString)
	}
	varDecNode.ChildNodes = append(varDecNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})

	GetNextToken()
	if CheckTokenType(types.IntegerKeyword) ||
		CheckTokenType(types.FloatKeyword) ||
		CheckTokenType(types.StringKeyword) ||
		CheckTokenType(types.BoolKeyword) {
		varDecNode.ChildNodes = append(varDecNode.ChildNodes, types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken})
	} else {
		return errors.New(errString)
	}
	varDecSTEntry.EntryType = types.STType(currentToken.TokenType)

	GetNextToken()
	if CheckTokenType(types.OpenSquareBracket) {
		varDecNode.ChildNodes = append(varDecNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})
		varDecSTEntry.EntryType = types.STType(varDecSTEntry.EntryType + "_array")
		varDecSTEntry.IsArray = true
	} else {
		(*parentNode).ChildNodes = append((*parentNode).ChildNodes, varDecNode)
		err := AddSymbolTableEntry(thisMakeGlobal, varDecSTEntry, localSymbolTable)
		if err != nil {
			return errors.New(errString + err.Error())
		}
		return nil
	}

	GetNextToken()
	if CheckTokenType(types.IntegerToken) {
		err := ParseBound(&varDecNode)
		if err != nil {
			return errors.New(errString + err.Error())
		}
	}

	varDecSTEntry.ArraySize = int(varDecNode.ChildNodes[5].ChildNodes[0].TerminalToken.IntValue)

	GetNextToken()
	if CheckTokenType(types.CloseSquareBracket) {
		varDecNode.ChildNodes = append(varDecNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})
	} else {
		return errors.New(errString)
	}

	GetNextToken()

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, varDecNode)
	err := AddSymbolTableEntry(thisMakeGlobal, varDecSTEntry, localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}
	return nil
}

func ParseBound(parentNode *types.ParseNode) error {
	boundNode := types.ParseNode{Production: types.BoundProd}
	errString := "\nError parsing bound"

	err := ParseInteger(&boundNode)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, boundNode)

	return nil
}

func ParseInteger(parentNode *types.ParseNode) error {
	integerNode := types.ParseNode{Production: types.NumberProd, TerminalToken: currentToken}
	errString := "\nError parsing number"

	if !CheckTokenType(types.IntegerToken) {
		return errors.New(errString)
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, integerNode)

	return nil
}

func ParseFloat(parentNode *types.ParseNode) error {
	floatNode := types.ParseNode{Production: types.NumberProd, TerminalToken: currentToken}
	errString := "\nError parsing number"

	if !CheckTokenType(types.FloatToken) {
		return errors.New(errString)
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, floatNode)

	return nil
}

func ParseString(parentNode *types.ParseNode) error {
	stringNode := types.ParseNode{Production: types.StringProd, TerminalToken: currentToken}
	errString := "\nError parsing string"

	if !CheckTokenType(types.StringToken) {
		return errors.New(errString)
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, stringNode)

	return nil
}

func ParseStatement(parentNode *types.ParseNode, localSymbolTable *map[string]types.STEntry) error {
	statementNode := types.ParseNode{Production: types.StatementProd}
	errString := "\nError parsing statement"

	if CheckIfIdentifierExists(localSymbolTable) {
		err := ParseAssignmentStatement(&statementNode, localSymbolTable)
		if err != nil {
			return errors.New(errString + err.Error())
		}
	} else if CheckTokenType(types.IfKeyword) {
		err := ParseIfStatement(&statementNode, localSymbolTable)
		if err != nil {
			return errors.New(errString + err.Error())
		}
	} else if CheckTokenType(types.ForKeyword) {
		err := ParseLoopStatement(&statementNode, localSymbolTable)
		if err != nil {
			return errors.New(errString + err.Error())
		}
	} else if CheckTokenType(types.ReturnKeyword) {
		err := ParseReturnStatement(&statementNode, localSymbolTable)
		if err != nil {
			return errors.New(errString + err.Error())
		}
	} else {
		return errors.New(errString)
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, statementNode)

	return nil
}

func CheckIfIdentifierExists(localSymbolTable *map[string]types.STEntry) bool {
	return CheckIfIdentifierExists_Local(localSymbolTable) || CheckIfIdentifierExists_Global() || CheckIfIdentifierExists_Builtin()
}

func CheckIfIdentifierExists_Local(localSymbolTable *map[string]types.STEntry) bool {
	if localSymbolTable != nil {
		_, exists := (*localSymbolTable)[currentToken.StringValue]
		if exists {
			return true
		} else {
			return false
		}
	} else {
		return false
	}
}

func CheckIfIdentifierExists_Global() bool {
	// localGST := globalSymbolTable
	// localGST["b"] = localGST["b"]
	// ct := currentToken
	// println(ct.StringValue)
	_, exists := globalSymbolTable[currentToken.StringValue]
	if exists {
		return true
	} else {
		return false
	}
}

func CheckIfIdentifierExists_Builtin() bool {
	_, exists := builtinSymbolTable[currentToken.StringValue]
	if exists {
		return true
	} else {
		return false
	}
}

func CheckIfIdentifierIsArray(localSymbolTable *map[string]types.STEntry) (bool, error) {
	errString := "\nError identifier not declared"

	if CheckIfIdentifierExists_Local(localSymbolTable) {
		if (*localSymbolTable)[currentToken.StringValue].EntryType == types.STVarIntegerArray ||
			(*localSymbolTable)[currentToken.StringValue].EntryType == types.STVarFloatArray ||
			(*localSymbolTable)[currentToken.StringValue].EntryType == types.STVarStringArray ||
			(*localSymbolTable)[currentToken.StringValue].EntryType == types.STVarBoolArray {
			return true, nil
		} else {
			return false, nil
		}
	} else if CheckIfIdentifierExists_Global() {
		if globalSymbolTable[currentToken.StringValue].EntryType == types.STVarIntegerArray ||
			globalSymbolTable[currentToken.StringValue].EntryType == types.STVarFloatArray ||
			globalSymbolTable[currentToken.StringValue].EntryType == types.STVarStringArray ||
			globalSymbolTable[currentToken.StringValue].EntryType == types.STVarBoolArray {
			return true, nil
		} else {
			return false, nil
		}
	} else {
		return false, errors.New(errString)
	}
}

func ParseAssignmentStatement(parentNode *types.ParseNode, localSymbolTable *map[string]types.STEntry) error {
	assignmentStatementNode := types.ParseNode{Production: types.AssignmentStatementProd}
	errString := "\nError parsing assignment statement"

	err := ParseDestination(&assignmentStatementNode, localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	GetNextToken()
	if !CheckTokenType(types.AssignmentOperator) {
		return errors.New(errString)
	}
	assignmentStatementNode.ChildNodes = append(assignmentStatementNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})

	GetNextToken()
	err = ParseExpression(&assignmentStatementNode, localSymbolTable) //, types.STVarInteger)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, assignmentStatementNode)

	return nil
}

func ParseIfStatement(parentNode *types.ParseNode, localSymbolTable *map[string]types.STEntry) error {
	ifStatementNode := types.ParseNode{Production: types.IfStatementProd}
	errString := "\nError parsing if statement"

	if !CheckTokenType(types.IfKeyword) {
		return errors.New(errString)
	}
	ifStatementNode.ChildNodes = append(ifStatementNode.ChildNodes, types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken})

	GetNextToken()
	if !CheckTokenType(types.OpenRoundBracket) {
		return errors.New(errString)
	}
	ifStatementNode.ChildNodes = append(ifStatementNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})

	GetNextToken()
	err := ParseExpression(&ifStatementNode, localSymbolTable) //, types.STVarBool)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	GetNextToken()
	if !CheckTokenType(types.CloseRoundBracket) {
		return errors.New(errString)
	}
	ifStatementNode.ChildNodes = append(ifStatementNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})

	GetNextToken()
	if !CheckTokenType(types.ThenKeyword) {
		return errors.New(errString)
	}
	ifStatementNode.ChildNodes = append(ifStatementNode.ChildNodes, types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken})

	GetNextToken()
	// Parse Statements here
	for {
		if CheckTokenType(types.EndKeyword) || CheckTokenType(types.ElseKeyword) {
			break
		}
		err = ParseStatement(&ifStatementNode, localSymbolTable)
		if err != nil {
			return errors.New(errString + err.Error())
		}
		GetNextToken()
		if CheckTokenType(types.SemiColonSymbol) {
			semiColonNode := types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken}
			ifStatementNode.ChildNodes = append(ifStatementNode.ChildNodes, semiColonNode)
		} else {
			return errors.New(errString)
		}

		GetNextToken()
	}

	if CheckTokenType(types.ElseKeyword) {
		GetNextToken()
		// Parse Statements here
		for {
			if CheckTokenType(types.EndKeyword) || CheckTokenType(types.ElseKeyword) {
				break
			}
			err = ParseStatement(&ifStatementNode, localSymbolTable)
			if err != nil {
				return errors.New(errString + err.Error())
			}
			GetNextToken()
			if CheckTokenType(types.SemiColonSymbol) {
				semiColonNode := types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken}
				ifStatementNode.ChildNodes = append(ifStatementNode.ChildNodes, semiColonNode)
			} else {
				return errors.New(errString)
			}

			GetNextToken()
		}
	}

	if !CheckTokenType(types.EndKeyword) {
		return errors.New(errString)
	}
	endKeywordNode := types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken}
	ifStatementNode.ChildNodes = append(ifStatementNode.ChildNodes, endKeywordNode)
	GetNextToken()
	if !CheckTokenType(types.IfKeyword) {
		return errors.New(errString)
	}
	ifKeywordNode := types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken}
	ifStatementNode.ChildNodes = append(ifStatementNode.ChildNodes, ifKeywordNode)

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, ifStatementNode)

	return nil
}

func ParseLoopStatement(parentNode *types.ParseNode, localSymbolTable *map[string]types.STEntry) error {
	loopStatementNode := types.ParseNode{Production: types.LoopStatementProd}
	errString := "\nError parsing loop statement"

	if !CheckTokenType(types.ForKeyword) {
		return errors.New(errString)
	}
	loopStatementNode.ChildNodes = append(loopStatementNode.ChildNodes, types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken})

	GetNextToken()
	if !CheckTokenType(types.OpenRoundBracket) {
		return errors.New(errString)
	}
	loopStatementNode.ChildNodes = append(loopStatementNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})

	// Parse assignment statement
	GetNextToken()
	if CheckIfIdentifierExists(localSymbolTable) {
		err := ParseAssignmentStatement(&loopStatementNode, localSymbolTable)
		if err != nil {
			return errors.New(errString + err.Error())
		}
	} else {
		return errors.New(errString)
	}

	// Parse semi colon
	GetNextToken()
	if !CheckTokenType(types.SemiColonSymbol) {
		return errors.New(errString)
	}
	loopStatementNode.ChildNodes = append(loopStatementNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})

	// Parse expression
	GetNextToken()
	err := ParseExpression(&loopStatementNode, localSymbolTable) //, types.STVarBool)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	GetNextToken()
	if !CheckTokenType(types.CloseRoundBracket) {
		return errors.New(errString)
	}
	loopStatementNode.ChildNodes = append(loopStatementNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})

	GetNextToken()
	// Parse Statements here
	for {
		if CheckTokenType(types.EndKeyword) {
			break
		}
		err := ParseStatement(&loopStatementNode, localSymbolTable)
		if err != nil {
			return errors.New(errString + err.Error())
		}
		GetNextToken()
		if CheckTokenType(types.SemiColonSymbol) {
			semiColonNode := types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken}
			loopStatementNode.ChildNodes = append(loopStatementNode.ChildNodes, semiColonNode)
		} else {
			return errors.New(errString)
		}

		GetNextToken()
	}

	if !CheckTokenType(types.EndKeyword) {
		return errors.New(errString)
	}
	endKeywordNode := types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken}
	loopStatementNode.ChildNodes = append(loopStatementNode.ChildNodes, endKeywordNode)
	GetNextToken()
	if !CheckTokenType(types.ForKeyword) {
		return errors.New(errString)
	}
	forKeywordNode := types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken}
	loopStatementNode.ChildNodes = append(loopStatementNode.ChildNodes, forKeywordNode)

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, loopStatementNode)

	return nil
}

func ParseReturnStatement(parentNode *types.ParseNode, localSymbolTable *map[string]types.STEntry) error {
	returnStatementNode := types.ParseNode{Production: types.ReturnStatementProd}
	errString := "\nError parsing return statement"

	if !CheckTokenType(types.ReturnKeyword) {
		return errors.New(errString)
	}
	returnStatementNode.ChildNodes = append(returnStatementNode.ChildNodes, types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken})

	// Parse expression
	GetNextToken()
	err := ParseExpression(&returnStatementNode, localSymbolTable) //, types.STVarBool)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, returnStatementNode)

	return nil
}

func ParseDestination(parentNode *types.ParseNode, localSymbolTable *map[string]types.STEntry) error {
	destinationNode := types.ParseNode{Production: types.DestinationProd}
	errString := "\nError parsing destination"

	destinationNode.ChildNodes = append(destinationNode.ChildNodes, types.ParseNode{Production: types.IdentifierProd, TerminalToken: currentToken})

	isArray, err := CheckIfIdentifierIsArray(localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	if CheckLookAhead(types.AssignmentOperator) {
		(*parentNode).ChildNodes = append((*parentNode).ChildNodes, destinationNode)
		return nil
	}

	GetNextToken()
	if CheckTokenType(types.OpenSquareBracket) && isArray {
		destinationNode.ChildNodes = append(destinationNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})
	} else if !CheckTokenType(types.OpenSquareBracket) && isArray {
		(*parentNode).ChildNodes = append((*parentNode).ChildNodes, destinationNode)
		return nil
	} else if !CheckTokenType(types.OpenSquareBracket) && !isArray {
		(*parentNode).ChildNodes = append((*parentNode).ChildNodes, destinationNode)
		return nil
	} else if CheckTokenType(types.OpenSquareBracket) && !isArray {
		return errors.New(errString)
	}

	GetNextToken() // TODO: switch back to this code after ParseExpression is finished
	err = ParseExpression(&destinationNode, localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	GetNextToken()
	if CheckTokenType(types.CloseSquareBracket) {
		destinationNode.ChildNodes = append(destinationNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})
	} else {
		return errors.New(errString)
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, destinationNode)

	return nil
}

func CheckIfEpsilon_Expression() bool {
	if CheckLookAhead(types.SemiColonSymbol) ||
		CheckLookAhead(types.CloseSquareBracket) ||
		CheckLookAhead(types.CloseRoundBracket) ||
		CheckLookAhead(types.CommaSymbol) ||
		CheckLookAhead(types.AdditionOperator) ||
		CheckLookAhead(types.SubtractionOperator) ||
		CheckLookAhead(types.MultiplicationOperator) ||
		CheckLookAhead(types.DivisionOperator) ||
		CheckLookAhead(types.GreaterThanOperator) ||
		CheckLookAhead(types.LessThanOperator) ||
		CheckLookAhead(types.GreaterThanEqualOperator) ||
		CheckLookAhead(types.LessThanEqualOperator) ||
		CheckLookAhead(types.LessThanOperator) ||
		CheckLookAhead(types.EqualOperator) ||
		CheckLookAhead(types.NotEqualOperator) {
		return true
	} else {
		return false
	}
}

func CheckIfEpsilon_ArithOp() bool {
	if CheckLookAhead(types.SemiColonSymbol) ||
		CheckLookAhead(types.CloseSquareBracket) ||
		CheckLookAhead(types.CloseRoundBracket) ||
		CheckLookAhead(types.CommaSymbol) ||
		CheckLookAhead(types.AndOperator) ||
		CheckLookAhead(types.OrOperator) ||
		CheckLookAhead(types.MultiplicationOperator) ||
		CheckLookAhead(types.DivisionOperator) ||
		CheckLookAhead(types.GreaterThanOperator) ||
		CheckLookAhead(types.LessThanOperator) ||
		CheckLookAhead(types.GreaterThanEqualOperator) ||
		CheckLookAhead(types.LessThanEqualOperator) ||
		CheckLookAhead(types.LessThanOperator) ||
		CheckLookAhead(types.EqualOperator) ||
		CheckLookAhead(types.NotEqualOperator) {
		return true
	} else {
		return false
	}
}

func CheckIfEpsilon_Relation() bool {
	if CheckLookAhead(types.SemiColonSymbol) ||
		CheckLookAhead(types.CloseSquareBracket) ||
		CheckLookAhead(types.CloseRoundBracket) ||
		CheckLookAhead(types.CommaSymbol) ||
		CheckLookAhead(types.AndOperator) ||
		CheckLookAhead(types.OrOperator) ||
		CheckLookAhead(types.AdditionOperator) ||
		CheckLookAhead(types.SubtractionOperator) ||
		CheckLookAhead(types.MultiplicationOperator) ||
		CheckLookAhead(types.DivisionOperator) {
		return true
	} else {
		return false
	}
}

func CheckIfEpsilon_Term() bool {
	if CheckLookAhead(types.SemiColonSymbol) ||
		CheckLookAhead(types.CloseSquareBracket) ||
		CheckLookAhead(types.CloseRoundBracket) ||
		CheckLookAhead(types.CommaSymbol) ||
		CheckLookAhead(types.AndOperator) ||
		CheckLookAhead(types.OrOperator) ||
		CheckLookAhead(types.AdditionOperator) ||
		CheckLookAhead(types.SubtractionOperator) ||
		CheckLookAhead(types.GreaterThanOperator) ||
		CheckLookAhead(types.LessThanOperator) ||
		CheckLookAhead(types.GreaterThanEqualOperator) ||
		CheckLookAhead(types.LessThanEqualOperator) ||
		CheckLookAhead(types.LessThanOperator) ||
		CheckLookAhead(types.EqualOperator) ||
		CheckLookAhead(types.NotEqualOperator) {
		return true
	} else {
		return false
	}
}

func ParseExpression(parentNode *types.ParseNode, localSymbolTable *map[string]types.STEntry) error {
	expressionNode := types.ParseNode{Production: types.ExpressionProd}
	errString := "\nError parsing expression"

	if CheckTokenType(types.NotOperator) {
		expressionNode.ChildNodes = append(expressionNode.ChildNodes, types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken})

		GetNextToken()
		err := ParseArithOp(&expressionNode, localSymbolTable) //, types.STVarBool)
		if err != nil {
			return errors.New(errString + err.Error())
		}

	} else {
		err := ParseArithOp(&expressionNode, localSymbolTable) //, types.STVarBool)
		if err != nil {
			return errors.New(errString + err.Error())
		}
	}

	// if CheckLookAhead(types.SemiColonSymbol) ||
	// 	CheckLookAhead(types.CloseSquareBracket) ||
	// 	CheckLookAhead(types.CloseRoundBracket) ||
	// 	CheckLookAhead(types.AndOperator) ||
	// 	CheckLookAhead(types.OrOperator) ||
	// 	CheckLookAhead(types.CommaSymbol) {
	// 	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, expressionNode)
	// 	return nil
	// }
	if CheckIfEpsilon_Expression() {
		(*parentNode).ChildNodes = append((*parentNode).ChildNodes, expressionNode)
		return nil
	}

	GetNextToken()
	err := ParseExpressionPrime(&expressionNode, localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, expressionNode)

	return nil
}

func ParseExpressionPrime(parentNode *types.ParseNode, localSymbolTable *map[string]types.STEntry) error {
	expressionPrimeNode := types.ParseNode{Production: types.ExpressionPrimeProd}
	errString := "\nError parsing expression prime"

	if CheckTokenType(types.AndOperator) ||
		CheckTokenType(types.OrOperator) {
		expressionPrimeNode.ChildNodes = append(expressionPrimeNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})
	} else {
		return errors.New(errString)
	}

	GetNextToken()
	// Parse ArithOp
	err := ParseArithOp(&expressionPrimeNode, localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	if CheckIfEpsilon_Expression() {
		(*parentNode).ChildNodes = append((*parentNode).ChildNodes, expressionPrimeNode)
		return nil
	}

	GetNextToken()
	// Parse ExpressionPrime
	err = ParseArithOpPrime(&expressionPrimeNode, localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, expressionPrimeNode)

	return nil
}

func ParseArithOp(parentNode *types.ParseNode, localSymbolTable *map[string]types.STEntry) error {
	arithOpNode := types.ParseNode{Production: types.ArithOpProd}
	errString := "\nError parsing arithmetic operation"

	err := ParseRelation(&arithOpNode, localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	if CheckIfEpsilon_ArithOp() {
		(*parentNode).ChildNodes = append((*parentNode).ChildNodes, arithOpNode)
		return nil
	}

	GetNextToken()
	err = ParseArithOpPrime(&arithOpNode, localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, arithOpNode)

	return nil
}

func ParseArithOpPrime(parentNode *types.ParseNode, localSymbolTable *map[string]types.STEntry) error {
	arithOpPrimeNode := types.ParseNode{Production: types.ArithOpPrimeProd}
	errString := "\nError parsing arithmetic operation prime"

	if CheckTokenType(types.AdditionOperator) ||
		CheckTokenType(types.SubtractionOperator) {
		arithOpPrimeNode.ChildNodes = append(arithOpPrimeNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})
	} else {
		return errors.New(errString)
	}

	GetNextToken()
	// Parse Relation
	err := ParseRelation(&arithOpPrimeNode, localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	if CheckIfEpsilon_ArithOp() {
		(*parentNode).ChildNodes = append((*parentNode).ChildNodes, arithOpPrimeNode)
		return nil
	}

	GetNextToken()
	// Parse ArithOpPrime
	err = ParseArithOpPrime(&arithOpPrimeNode, localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, arithOpPrimeNode)

	return nil
}

func ParseRelation(parentNode *types.ParseNode, localSymbolTable *map[string]types.STEntry) error {
	relationNode := types.ParseNode{Production: types.RelationProd}
	errString := "\nError parsing relation"

	err := ParseTerm(&relationNode, localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	if CheckIfEpsilon_Relation() {
		(*parentNode).ChildNodes = append((*parentNode).ChildNodes, relationNode)
		return nil
	}

	GetNextToken()
	err = ParseRelationPrime(&relationNode, localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, relationNode)

	return nil
}

func ParseRelationPrime(parentNode *types.ParseNode, localSymbolTable *map[string]types.STEntry) error {
	relationPrimeNode := types.ParseNode{Production: types.RelationPrimeProd}
	errString := "\nError parsing relation prime"

	if CheckTokenType(types.LessThanOperator) ||
		CheckTokenType(types.GreaterThanEqualOperator) ||
		CheckTokenType(types.LessThanEqualOperator) ||
		CheckTokenType(types.GreaterThanOperator) ||
		CheckTokenType(types.EqualOperator) ||
		CheckTokenType(types.NotEqualOperator) {
		relationPrimeNode.ChildNodes = append(relationPrimeNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})
	} else {
		return errors.New(errString)
	}

	GetNextToken()
	// Parse Term
	err := ParseTerm(&relationPrimeNode, localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	if CheckIfEpsilon_Relation() {
		(*parentNode).ChildNodes = append((*parentNode).ChildNodes, relationPrimeNode)
		return nil
	}

	GetNextToken()
	// Parse RelationPrime
	err = ParseRelationPrime(&relationPrimeNode, localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, relationPrimeNode)

	return nil
}

func ParseTerm(parentNode *types.ParseNode, localSymbolTable *map[string]types.STEntry) error {
	termNode := types.ParseNode{Production: types.TermProd}
	errString := "\nError parsing term"

	err := ParseFactor(&termNode, localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	if CheckIfEpsilon_Term() {
		(*parentNode).ChildNodes = append((*parentNode).ChildNodes, termNode)
		return nil
	}

	GetNextToken()
	err = ParseTermPrime(&termNode, localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, termNode)

	return nil
}

func ParseTermPrime(parentNode *types.ParseNode, localSymbolTable *map[string]types.STEntry) error {
	termPrimeNode := types.ParseNode{Production: types.TermPrimeProd}
	errString := "\nError parsing term prime"

	if CheckTokenType(types.MultiplicationOperator) ||
		CheckTokenType(types.DivisionOperator) {
		termPrimeNode.ChildNodes = append(termPrimeNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})
	} else {
		return errors.New(errString)
	}

	GetNextToken()
	// Parse Factor
	err := ParseFactor(&termPrimeNode, localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	if CheckIfEpsilon_Term() {
		(*parentNode).ChildNodes = append((*parentNode).ChildNodes, termPrimeNode)
		return nil
	}

	GetNextToken()
	// Parse TermPrime
	err = ParseTermPrime(&termPrimeNode, localSymbolTable)
	if err != nil {
		return errors.New(errString + err.Error())
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, termPrimeNode)

	return nil
}

func ParseFactor(parentNode *types.ParseNode, localSymbolTable *map[string]types.STEntry) error {
	factorNode := types.ParseNode{Production: types.FactorProd}
	errString := "\nError parsing factor"

	if CheckTokenType(types.OpenRoundBracket) {
		factorNode.ChildNodes = append(factorNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})

		GetNextToken()
		err := ParseExpression(&factorNode, localSymbolTable)
		if err != nil {
			return errors.New(errString + err.Error())
		}

		GetNextToken()
		if !CheckTokenType(types.CloseRoundBracket) {
			return errors.New(errString + err.Error())
		}
		factorNode.ChildNodes = append(factorNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})

	} else if CheckTokenType(types.IdentifierToken) {
		entryLocal, isLocal := (*localSymbolTable)[currentToken.StringValue]
		if isLocal {
			if entryLocal.EntryType == types.STProcedure {
				err := ParseProcedureCall(&factorNode, localSymbolTable)
				if err != nil {
					return errors.New(errString + err.Error())
				}
			} else {
				err := ParseName(&factorNode, localSymbolTable)
				if err != nil {
					return errors.New(errString + err.Error())
				}
			}
		} else {
			entryGlobal, isGlobal := globalSymbolTable[currentToken.StringValue]
			if isGlobal {
				if entryGlobal.EntryType == types.STProcedure {
					err := ParseProcedureCall(&factorNode, localSymbolTable)
					if err != nil {
						return errors.New(errString + err.Error())
					}
				} else {
					err := ParseName(&factorNode, &globalSymbolTable)
					if err != nil {
						return errors.New(errString + err.Error())
					}
				}
			} else {
				entryBuiltin, isBuiltin := builtinSymbolTable[currentToken.StringValue]
				if isBuiltin {
					if entryBuiltin.EntryType == types.STProcedure {
						err := ParseProcedureCall(&factorNode, localSymbolTable)
						if err != nil {
							return errors.New(errString + err.Error())
						}
					} else {
						return errors.New(errString)
					}
				} else {
					return errors.New(errString)
				}
			}
		}
	} else if CheckTokenType(types.IntegerToken) {
		err := ParseInteger(&factorNode)
		if err != nil {
			return errors.New(errString + err.Error())
		}
	} else if CheckTokenType(types.FloatToken) {
		err := ParseFloat(&factorNode)
		if err != nil {
			return errors.New(errString + err.Error())
		}
	} else if CheckTokenType(types.StringToken) {
		err := ParseString(&factorNode)
		if err != nil {
			return errors.New(errString + err.Error())
		}
	} else if CheckTokenType(types.TrueKeyword) {
		factorNode.ChildNodes = append(factorNode.ChildNodes, types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken})
	} else if CheckTokenType(types.FalseKeyword) {
		factorNode.ChildNodes = append(factorNode.ChildNodes, types.ParseNode{Production: types.KeywordTerminal, TerminalToken: currentToken})
	} else if CheckTokenType(types.SubtractionOperator) {
		factorNode.ChildNodes = append(factorNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})
		GetNextToken()
		if CheckTokenType(types.IdentifierToken) {
			entryLocal, isLocal := (*localSymbolTable)[currentToken.StringValue]
			if isLocal {
				if entryLocal.EntryType == types.STProcedure {
					return errors.New(errString)
				} else {
					err := ParseName(&factorNode, localSymbolTable)
					if err != nil {
						return errors.New(errString + err.Error())
					}
				}
			} else {
				entryGlobal, isGlobal := globalSymbolTable[currentToken.StringValue]
				if isGlobal {
					if entryGlobal.EntryType == types.STProcedure {
						return errors.New(errString)
					} else {
						err := ParseName(&factorNode, localSymbolTable)
						if err != nil {
							return errors.New(errString + err.Error())
						}
					}
				} else {
					return errors.New(errString)
				}
			}
		} else if CheckTokenType(types.IntegerToken) {
			err := ParseInteger(&factorNode)
			if err != nil {
				return errors.New(errString + err.Error())
			}
		} else if CheckTokenType(types.FloatToken) {
			err := ParseFloat(&factorNode)
			if err != nil {
				return errors.New(errString + err.Error())
			}
		} else {
			return errors.New(errString)
		}
	} else {
		return errors.New(errString)
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, factorNode)

	return nil
}

func ParseProcedureCall(parentNode *types.ParseNode, localSymbolTable *map[string]types.STEntry) error {
	procedureCallNode := types.ParseNode{Production: types.ProcedureCallProd}
	errString := "\nError parsing procedure call"

	if !CheckIfIdentifierExists(localSymbolTable) {
		return errors.New(errString)
	}
	if !CheckTokenType(types.IdentifierToken) {
		return errors.New(errString)
	}
	procedureCallNode.ChildNodes = append(procedureCallNode.ChildNodes, types.ParseNode{Production: types.IdentifierProd, TerminalToken: currentToken})

	GetNextToken()
	if !CheckTokenType(types.OpenRoundBracket) {
		return errors.New(errString)
	}
	procedureCallNode.ChildNodes = append(procedureCallNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})

	GetNextToken()
	if !CheckTokenType(types.CloseRoundBracket) {
		err := ParseArgumentList(&procedureCallNode, localSymbolTable)
		if err != nil {
			return errors.New(errString + err.Error())
		}
		// GetNextToken()
		if !CheckTokenType(types.CloseRoundBracket) {
			return errors.New(errString)
		}
		procedureCallNode.ChildNodes = append(procedureCallNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})
	} else {
		procedureCallNode.ChildNodes = append(procedureCallNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, procedureCallNode)

	return nil
}

func ParseArgumentList(parentNode *types.ParseNode, localSymbolTable *map[string]types.STEntry) error {
	argumentListNode := types.ParseNode{Production: types.ArgumentListProd}
	errString := "\nError parsing argument list"

	for {
		err := ParseExpression(&argumentListNode, localSymbolTable)
		if err != nil {
			return errors.New(errString + err.Error())
		}
		GetNextToken()
		if CheckTokenType(types.CommaSymbol) {
			argumentListNode.ChildNodes = append(argumentListNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})
			GetNextToken()
		} else if CheckTokenType(types.CloseRoundBracket) {
			(*parentNode).ChildNodes = append((*parentNode).ChildNodes, argumentListNode)
			return nil
		} else {
			return errors.New(errString)
		}
	}
}

func ParseName(parentNode *types.ParseNode, localSymbolTable *map[string]types.STEntry) error {
	nameNode := types.ParseNode{Production: types.NameProd}
	errString := "\nError parsing name"

	if !CheckIfIdentifierExists(localSymbolTable) {
		return errors.New(errString)
	}
	if !CheckTokenType(types.IdentifierToken) {
		return errors.New(errString)
	}
	nameNode.ChildNodes = append(nameNode.ChildNodes, types.ParseNode{Production: types.IdentifierProd, TerminalToken: currentToken})

	if CheckLookAhead(types.OpenSquareBracket) {
		GetNextToken()
		nameNode.ChildNodes = append(nameNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})

		GetNextToken()
		err := ParseExpression(&nameNode, localSymbolTable)
		if err != nil {
			return errors.New(errString + err.Error())
		}

		GetNextToken()
		if !CheckTokenType(types.CloseSquareBracket) {
			return errors.New(errString)
		}
		nameNode.ChildNodes = append(nameNode.ChildNodes, types.ParseNode{Production: types.SymbolTerminal, TerminalToken: currentToken})
	}

	(*parentNode).ChildNodes = append((*parentNode).ChildNodes, nameNode)

	return nil
}

func GetGlobalSymbolTable() map[string]types.STEntry {
	return globalSymbolTable
}

func GetBuiltinSymbolTable() map[string]types.STEntry {
	return builtinSymbolTable
}
