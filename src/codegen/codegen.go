// The entry point function is GenerateC
// GenerateC setups the head and foot of the C program then
// the function calls GenNode which recursively visits each node
// of the parse tree generated by the parser.
// Functions such as GenExpression or GenVariableDeclaration
// are called depending on the visited node's production type.
// These functions generate the appropraite C code.

package codegen

import (
	"compiler/src/types"
	"log"
	"os"
	"strconv"
)

var program = ""
var sp = 1024
var fp = 0
var sdp = 0
var tvc = 0

var globalSymbolTable = map[string]types.STEntry{}
var builtinSymbolTable = map[string]types.STEntry{}

func GenerateC(node *types.ParseNode, parseGlobalSymbolTable map[string]types.STEntry, parseBuiltinSymbolTable map[string]types.STEntry) {
	globalSymbolTable = parseGlobalSymbolTable
	builtinSymbolTable = parseBuiltinSymbolTable

	GenerateHead()
	GenNode(node, &globalSymbolTable, types.STEntry{})
	GenerateFoot()

	err := os.WriteFile("c/out.c", []byte(program), 0777)
	if err != nil {
		log.Fatal(err)
	}
}

func GenerateHead() {
	program += "#include <stdio.h>\n"
	program += "#include <string.h>\n"
	program += "#include <math.h>\n"
	program += "\n"
	program += "int main () {\n"
	program += "    float R[16];\n"
	program += "    float MM[1024 * 1024];\n"
}

func GenerateFoot() {
	program += "    return 0;\n"
	program += "}"
}

func GenNode(node *types.ParseNode, localSymbolTable *map[string]types.STEntry, stEntry types.STEntry) {
	var localST map[string]types.STEntry
	localST = *localSymbolTable
	if node.Production == types.ProcedureDeclarationProd {
		localST = node.ProcLocalSymbolTable
	}
	var entry types.STEntry
	entry = stEntry
	var identifier types.ParseNode
	if node.Production == types.ProcedureDeclarationProd {
		header := node.ChildNodes[0]
		// if header.ChildNodes[0].TerminalToken.TokenType == types.GlobalKeyword {
		// 	identifier = node.ChildNodes[2]
		// } else {
		// 	identifier = node.ChildNodes[1]
		// }
		identifier = header.ChildNodes[1]
		entry = localST[identifier.TerminalToken.StringValue]
	}

	for _, child := range node.ChildNodes {
		GenNode(&child, &localST, entry)
	}

	// if node.Production == types.DeclarationProd {
	// 	GenDeclaration(node, &localST)
	// }
	if node.Production == types.VariableDeclarationProd {
		GenVariableDeclaration(node, &localST)
	}
	if node.Production == types.ProcedureDeclarationProd {
		GenProcedureDeclaration(node, &localST)
	}
	if node.Production == types.AssignmentStatementProd {
		// for rule 14
		GenAssignmentStatement(node, &localST)
	}
	if node.Production == types.LoopStatementProd {
		// for rule 15
		// check assignment statement
		GenLoopStatement(node, &localST, entry)
	}
	if node.Production == types.IfStatementProd {
		// for rule 15
		// check assignment statement
		GenIfStatement(node, &localST, entry)
	}
	if node.Production == types.ReturnStatementProd {
		// for rule 15
		// check assignment statement
		GenReturnStatement(node, &localST, entry)
	}
}

func GenDeclaration(node *types.ParseNode, localSymbolTable *map[string]types.STEntry) {

}

func GenVariableDeclaration(node *types.ParseNode, localSymbolTable *map[string]types.STEntry) {
	// errString := "Code Generation Error: "

	identifier := node.ChildNodes[1].TerminalToken.StringValue
	var stEntry types.STEntry
	stEntryLocal, existsLocal := (*localSymbolTable)[identifier]
	stEntryGlobal, existsGlobal := globalSymbolTable[identifier]
	if existsLocal {
		stEntry = stEntryLocal
	} else if existsGlobal {
		stEntry = stEntryGlobal
	}

	stEntry.Pointer = sp

	if existsLocal {
		(*localSymbolTable)[identifier] = stEntry
	} else if existsGlobal {
		globalSymbolTable[identifier] = stEntry
	}

	sp += 1
}

func GenProcedureDeclaration(node *types.ParseNode, localSymbolTable *map[string]types.STEntry) {

}

func GenAssignmentStatement(node *types.ParseNode, localSymbolTable *map[string]types.STEntry) {
	identifier := node.ChildNodes[0].ChildNodes[0].TerminalToken.StringValue
	var stEntry types.STEntry
	stEntryLocal, existsLocal := (*localSymbolTable)[identifier]
	stEntryGlobal, existsGlobal := globalSymbolTable[identifier]
	if existsLocal {
		stEntry = stEntryLocal
	} else if existsGlobal {
		stEntry = stEntryGlobal
	}

	if stEntry.IsArray {
		if len(node.ChildNodes[0].ChildNodes) > 1 {
			GenExpression(&node.ChildNodes[0].ChildNodes[2], localSymbolTable)
			offset := sp - 1
			GenExpression(&node.ChildNodes[2], localSymbolTable)
			offset = (sp - 1) - offset
			program += "R[2] = MM[(int)R[0] - 1];\n"
			program += "MM[" + strconv.Itoa(stEntry.Pointer) + " + (int)MM[" + strconv.Itoa(offset) + "]] = R[2];\n"
			program += "R[0] = R[0] + 1;\n"
			sp += 1
		} else {
			// full array
		}

	} else {
		GenExpression(&node.ChildNodes[2], localSymbolTable)
		program += "R[2] = MM[(int)R[0] - 1];\n"
		program += "MM[" + strconv.Itoa(stEntry.Pointer) + "] = R[2];\n"
		program += "R[0] = R[0] + 1;\n"
		sp += 1
	}
}

func GenLoopStatement(node *types.ParseNode, localSymbolTable *map[string]types.STEntry, stEntry types.STEntry) {

}

func GenIfStatement(node *types.ParseNode, localSymbolTable *map[string]types.STEntry, stEntry types.STEntry) {

}

func GenReturnStatement(node *types.ParseNode, localSymbolTable *map[string]types.STEntry, stEntry types.STEntry) {

}

func GenExpression(node *types.ParseNode, localSymbolTable *map[string]types.STEntry) (types.STEntry, types.STType) {

	stEntry, stType := GenArithOp(&node.ChildNodes[0], localSymbolTable)
	offset := sp - 1

	if len(node.ChildNodes) > 1 {
		operation := string(node.ChildNodes[1].ChildNodes[0].TerminalToken.TokenType)
		GenExpressionPrime(&node.ChildNodes[1].ChildNodes[2], localSymbolTable)
		offset = (sp - 1) - offset
		program += "R[2] = MM[(int)R[0] - 1 - " + strconv.Itoa(offset) + "];\n"
		program += "R[3] = MM[(int)R[0] - 1];\n"
		program += "R[4] = R[2] " + operation + " R[3];\n"
		program += "MM[(int)R[0]] = R[4];\n"
		program += "R[0] = R[0] + 1;\n"
		sp += 1
	}
	return stEntry, stType
}

func GenExpressionPrime(node *types.ParseNode, localSymbolTable *map[string]types.STEntry) (types.STEntry, types.STType) {
	operation := string(node.ChildNodes[0].TerminalToken.TokenType)

	stEntry, stType := GenArithOp(&node.ChildNodes[1], localSymbolTable)
	offset := sp - 1

	if len(node.ChildNodes) > 2 {
		GenExpressionPrime(&node.ChildNodes[2], localSymbolTable)
		offset = (sp - 1) - offset
		program += "R[2] = MM[(int)R[0] - 1 - " + strconv.Itoa(offset) + "];\n"
		program += "R[3] = MM[(int)R[0] - 1];\n"
		program += "R[4] = R[2] " + operation + " R[3];\n"
		program += "MM[(int)R[0]] = R[4];\n"
		program += "R[0] = R[0] + 1;\n"
		sp += 1
	}
	return stEntry, stType
}

func GenArithOp(node *types.ParseNode, localSymbolTable *map[string]types.STEntry) (types.STEntry, types.STType) {
	stEntry, stType := GenRelation(&node.ChildNodes[0], localSymbolTable)
	offset := sp - 1

	if len(node.ChildNodes) > 1 {
		operation := string(node.ChildNodes[1].ChildNodes[0].TerminalToken.TokenType)
		GenArithOpPrime(&node.ChildNodes[1].ChildNodes[2], localSymbolTable)
		offset = (sp - 1) - offset
		program += "R[2] = MM[(int)R[0] - 1 - " + strconv.Itoa(offset) + "];\n"
		program += "R[3] = MM[(int)R[0] - 1];\n"
		program += "R[4] = R[2] " + operation + " R[3];\n"
		program += "MM[(int)R[0]] = R[4];\n"
		program += "R[0] = R[0] + 1;\n"
		sp += 1
	}
	return stEntry, stType
}

func GenArithOpPrime(node *types.ParseNode, localSymbolTable *map[string]types.STEntry) (types.STEntry, types.STType) {
	operation := string(node.ChildNodes[0].TerminalToken.TokenType)

	stEntry, stType := GenRelation(&node.ChildNodes[1], localSymbolTable)
	offset := sp - 1

	if len(node.ChildNodes) > 2 {
		GenArithOpPrime(&node.ChildNodes[2], localSymbolTable)
		offset = (sp - 1) - offset
		program += "R[2] = MM[(int)R[0] - 1 - " + strconv.Itoa(offset) + "];\n"
		program += "R[3] = MM[(int)R[0] - 1];\n"
		program += "R[4] = R[2] " + operation + " R[3];\n"
		program += "MM[(int)R[0]] = R[4];\n"
		program += "R[0] = R[0] + 1;\n"
		sp += 1
	}

	return stEntry, stType
}

func GenRelation(node *types.ParseNode, localSymbolTable *map[string]types.STEntry) (types.STEntry, types.STType) {
	stEntry, stType := GenTerm(&node.ChildNodes[0], localSymbolTable)
	offset := sp - 1

	if len(node.ChildNodes) > 1 {
		operation := string(node.ChildNodes[1].ChildNodes[0].TerminalToken.TokenType)
		GenRelationPrime(&node.ChildNodes[1].ChildNodes[2], localSymbolTable)
		offset = (sp - 1) - offset
		program += "R[2] = MM[(int)R[0] - 1 - " + strconv.Itoa(offset) + "];\n"
		program += "R[3] = MM[(int)R[0] - 1];\n"
		program += "R[4] = R[2] " + operation + " R[3];\n"
		program += "MM[(int)R[0]] = R[4];\n"
		program += "R[0] = R[0] + 1;\n"
		sp += 1
	}
	return stEntry, stType
}

func GenRelationPrime(node *types.ParseNode, localSymbolTable *map[string]types.STEntry) (types.STEntry, types.STType) {
	operation := string(node.ChildNodes[0].TerminalToken.TokenType)

	stEntry, stType := GenTerm(&node.ChildNodes[1], localSymbolTable)
	offset := sp - 1

	if len(node.ChildNodes) > 2 {
		GenRelationPrime(&node.ChildNodes[2], localSymbolTable)
		offset = (sp - 1) - offset
		program += "R[2] = MM[(int)R[0] - 1 - " + strconv.Itoa(offset) + "];\n"
		program += "R[3] = MM[(int)R[0] - 1];\n"
		program += "R[4] = R[2] " + operation + " R[3];\n"
		program += "MM[(int)R[0]] = R[4];\n"
		program += "R[0] = R[0] + 1;\n"
		sp += 1
	}

	return stEntry, stType
}

func GenTerm(node *types.ParseNode, localSymbolTable *map[string]types.STEntry) (types.STEntry, types.STType) {
	stEntry, stType := GenFactor(&node.ChildNodes[0], localSymbolTable)
	offset := sp - 1

	if len(node.ChildNodes) > 1 {
		operation := string(node.ChildNodes[1].ChildNodes[0].TerminalToken.TokenType)
		GenTermPrime(&node.ChildNodes[1].ChildNodes[2], localSymbolTable)
		offset = (sp - 1) - offset
		program += "R[2] = MM[(int)R[0] - 1 - " + strconv.Itoa(offset) + "];\n"
		program += "R[3] = MM[(int)R[0] - 1];\n"
		program += "R[4] = R[2] " + operation + " R[3];\n"
		program += "MM[(int)R[0]] = R[4];\n"
		program += "R[0] = R[0] + 1;\n"
		sp += 1
	}

	return stEntry, stType
}

func GenTermPrime(node *types.ParseNode, localSymbolTable *map[string]types.STEntry) (types.STEntry, types.STType) {
	operation := string(node.ChildNodes[0].TerminalToken.TokenType)

	stEntry, stType := GenFactor(&node.ChildNodes[1], localSymbolTable)
	offset := sp - 1

	if len(node.ChildNodes) > 2 {
		GenTermPrime(&node.ChildNodes[2], localSymbolTable)
		offset = (sp - 1) - offset
		program += "R[2] = MM[(int)R[0] - 1 - " + strconv.Itoa(offset) + "];\n"
		program += "R[3] = MM[(int)R[0] - 1];\n"
		program += "R[4] = R[2] " + operation + " R[3];\n"
		program += "MM[(int)R[0]] = R[4];\n"
		program += "R[0] = R[0] + 1;\n"
		sp += 1
	}

	return stEntry, stType
}

func GenFactor(node *types.ParseNode, localSymbolTable *map[string]types.STEntry) (types.STEntry, types.STType) {
	var stType types.STType
	var stEntry types.STEntry
	if node.ChildNodes[0].TerminalToken.TokenType == types.SubtractionOperator {
		if node.ChildNodes[1].Production == types.NameProd {
			stEntry, stType = GenName(&node.ChildNodes[1], localSymbolTable)
			if stType != types.STVarBoolArray && stType != types.STVarFloatArray && stType != types.STVarInteger && stType != types.STVarStringArray {
				program += "R[2] = MM[(int)R[0] - 1];\n"
				program += "R[2] = R[2] * -1;\n"
				program += "MM[(int)R[0] - 1] = R[2];\n"
			} else {
				offset := stEntry.ArraySize
				for i := 0; i < stEntry.ArraySize; i++ {
					program += "R[2] = MM[(int)R[0] - 1 - " + strconv.Itoa(offset) + " + " + strconv.Itoa(i) + "];\n"
					program += "R[2] = R[2] * -1;\n"
					program += "MM[(int)R[0] - 1 - " + strconv.Itoa(offset) + " + " + strconv.Itoa(i) + "] = R[2];\n"
				}
			}
		} else if node.ChildNodes[1].Production == types.NumberProd {
			if node.ChildNodes[1].TerminalToken.TokenType == types.FloatToken {
				program += "R[2] = " + strconv.FormatFloat(node.ChildNodes[0].TerminalToken.FloatValue, 'f', 10, 64) + ";\n"
				program += "R[2] = R[2] * -1;\n"
				program += "MM[(int)R[0]] = R[2];\n"
				program += "R[0] = R[0] + 1;\n"
				sp += 1
				stType = types.STVarFloat
			} else if node.ChildNodes[1].TerminalToken.TokenType == types.IntegerToken {
				program += "R[2] = " + strconv.FormatInt(node.ChildNodes[0].TerminalToken.IntValue, 10) + ";\n"
				program += "R[2] = R[2] * -1;\n"
				program += "MM[(int)R[0]] = R[2];\n"
				program += "R[0] = R[0] + 1;\n"
				sp += 1
				stType = types.STVarInteger
			}
		}
	} else if node.ChildNodes[0].TerminalToken.TokenType == types.OpenRoundBracket {
		stEntry, stType = GenExpression(&node.ChildNodes[1], localSymbolTable)
	} else if node.ChildNodes[0].Production == types.ProcedureCallProd {
		stEntry, stType = GenProcedureCall(&node.ChildNodes[0], localSymbolTable)
	} else if node.ChildNodes[0].Production == types.NameProd {
		stEntry, stType = GenName(&node.ChildNodes[0], localSymbolTable)
	} else if node.ChildNodes[0].Production == types.NumberProd {
		if node.ChildNodes[0].TerminalToken.TokenType == types.FloatToken {
			program += "R[2] = " + strconv.FormatFloat(node.ChildNodes[0].TerminalToken.FloatValue, 'f', 10, 64) + ";\n"
			program += "MM[(int)R[0]] = R[2];\n"
			program += "R[0] = R[0] + 1;\n"
			sp += 1
			stType = types.STVarFloat
		} else if node.ChildNodes[0].TerminalToken.TokenType == types.IntegerToken {
			program += "R[2] = " + strconv.FormatInt(node.ChildNodes[0].TerminalToken.IntValue, 10) + ";\n"
			program += "MM[(int)R[0]] = R[2];\n"
			program += "R[0] = R[0] + 1;\n"
			sp += 1
			stType = types.STVarInteger
		}
	} else if node.ChildNodes[0].Production == types.StringProd {
		program += "strcpy((char *)(MM+" + strconv.Itoa(sdp) + "),\"" + node.ChildNodes[0].TerminalToken.StringValue + "\");\n"
		program += "R[2] = " + strconv.Itoa(sdp) + ";\n"
		program += "MM[(int)R[0]] = R[2];\n"
		program += "R[0] = R[0] + 1;\n"
		sdp += len(node.ChildNodes[0].TerminalToken.StringValue)
		sp += 1
		stType = types.STVarString
	} else if node.ChildNodes[0].TerminalToken.TokenType == types.TrueKeyword {
		program += "R[2] = 1;\n"
		program += "MM[(int)R[0]] = R[2];\n"
		program += "R[0] = R[0] + 1;\n"
		sp += 1
		stType = types.STVarBool
	} else if node.ChildNodes[0].TerminalToken.TokenType == types.FalseKeyword {
		program += "R[2] = 0;\n"
		program += "MM[(int)R[0]] = R[2];\n"
		program += "R[0] = R[0] + 1;\n"
		sp += 1
		stType = types.STVarBool
	}
	return stEntry, stType
}

func GenProcedureCall(node *types.ParseNode, localSymbolTable *map[string]types.STEntry) (types.STEntry, types.STType) {
	lbst := builtinSymbolTable
	var stType types.STType
	identifier := node.ChildNodes[0].TerminalToken.StringValue
	var stEntry types.STEntry
	stEntryLocal, existsLocal := (*localSymbolTable)[identifier]
	stEntryGlobal, existsGlobal := globalSymbolTable[identifier]
	_, existsBuiltin := lbst[identifier]
	if existsLocal {
		stEntry = stEntryLocal
	} else if existsGlobal {
		stEntry = stEntryGlobal
	} else if existsBuiltin {
		if len(node.ChildNodes) > 3 {
			GenExpression(&node.ChildNodes[2], localSymbolTable)
		}
		if identifier == "putbool" {
			program += "R[2] = MM[(int)R[0] - 1];\n"
			program += "printf(\"%d\\n\", (int)R[2]);\n"
		} else if identifier == "putinteger" {
			program += "R[2] = MM[(int)R[0] - 1];\n"
			program += "printf(\"%d\\n\", (int)R[2]);\n"
		} else if identifier == "putfloat" {
			program += "R[2] = MM[(int)R[0] - 1];\n"
			program += "printf(\"%f\\n\", R[2]);\n"
		} else if identifier == "putstring" {
			program += "R[2] = MM[(int)R[0] - 1];\n"
			program += "printf(\"%s\\n\", (char *)(MM+(int)R[2]));\n"
		} else if identifier == "getbool" {
			temp := "tmp_" + strconv.Itoa(tvc)
			program += "int " + temp + ";\n"
			program += "scanf(\"%d\", &" + temp + ");\n"
			program += "R[3] = " + temp + ";\n"
			program += "MM[(int)R[0]] = R[3];\n"
			program += "R[0] = R[0] + 1;\n"
			sp += 1
			tvc += 1
		} else if identifier == "getinteger" {
			temp := "tmp_" + strconv.Itoa(tvc)
			program += "int " + temp + ";\n"
			program += "scanf(\"%d\", &" + temp + ");\n"
			program += "R[3] = " + temp + ";\n"
			program += "MM[(int)R[0]] = R[3];\n"
			program += "R[0] = R[0] + 1;\n"
			sp += 1
			tvc += 1
		} else if identifier == "getfloat" {
			temp := "tmp_" + strconv.Itoa(tvc)
			program += "float " + temp + ";\n"
			program += "scanf(\"%f\", &" + temp + ");\n"
			program += "R[3] = " + temp + ";\n"
			program += "MM[(int)R[0]] = R[3];\n"
			program += "R[0] = R[0] + 1;\n"
			sp += 1
			tvc += 1
		} else if identifier == "getstring" {
			temp := "tmp_" + strconv.Itoa(tvc)
			program += "char " + temp + "[80];\n"
			program += "scanf(\"%s\", " + temp + ");\n"
			program += "strcpy((char *)(MM+" + strconv.Itoa(sdp) + "), " + temp + ");\n"
			program += "R[3] = " + strconv.Itoa(sdp) + ";\n"
			program += "MM[(int)R[0]] = R[3];\n"
			program += "R[0] = R[0] + 1;\n"
			sp += 1
			tvc += 1
		} else if identifier == "sqrt" {
			temp := "tmp_" + strconv.Itoa(tvc)
			program += "float " + temp + ";\n"
			program += "R[2] = MM[(int)R[0] - 1];\n"
			program += "R[3] = " + "(float) sqrt((int)R[2]);\n"
			program += "MM[(int)R[0]] = R[3];\n"
			program += "R[0] = R[0] + 1;\n"
			sp += 1
			tvc += 1
		}
	}

	return stEntry, stType
}

func GenName(node *types.ParseNode, localSymbolTable *map[string]types.STEntry) (types.STEntry, types.STType) {
	identifier := node.ChildNodes[0].TerminalToken.StringValue

	var stEntry types.STEntry
	stEntryLocal, existsLocal := (*localSymbolTable)[identifier]
	stEntryGlobal, existsGlobal := globalSymbolTable[identifier]
	if existsLocal {
		stEntry = stEntryLocal
	} else if existsGlobal {
		stEntry = stEntryGlobal
	}

	pointer := stEntry.Pointer
	program += "R[2] = " + strconv.Itoa(pointer) + ";\n"

	if len(node.ChildNodes) > 1 {
		GenExpression(&node.ChildNodes[2], localSymbolTable)
		program += "R[3] = MM[(int)R[0] - 1];\n"
	} else {
		program += "R[3] = 0;\n"
	}

	if len(node.ChildNodes) == 1 && stEntry.IsArray {
		for i := 0; i < stEntry.ArraySize; i++ {
			program += "R[4] = MM[(int)R[2] + " + strconv.Itoa(i) + "];\n"
			program += "MM[(int)R[0]] = R[4];\n"
			program += "R[0] = R[0] + 1;\n"
			sp += 1
		}
	} else {
		program += "R[4] = MM[(int)R[2] + (int)R[3]];\n"
		program += "MM[(int)R[0]] = R[4];\n"
		program += "R[0] = R[0] + 1;\n"
		sp += 1
	}

	if len(node.ChildNodes) > 1 {
		if stEntry.EntryType == types.STVarBoolArray {
			return stEntry, types.STVarBool
		} else if stEntry.EntryType == types.STVarFloatArray {
			return stEntry, types.STVarFloat
		} else if stEntry.EntryType == types.STVarIntegerArray {
			return stEntry, types.STVarInteger
		} else if stEntry.EntryType == types.STVarStringArray {
			return stEntry, types.STVarString
		}
	} else {
		return stEntry, stEntry.EntryType
	}
	return stEntry, stEntry.EntryType
}
